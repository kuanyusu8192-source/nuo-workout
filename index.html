<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>NUO Pro Icon Generator</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            text-align: center; 
            padding: 40px; 
            background-color: #eef2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h2 { color: #2c3e50; }
        .preview-area {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        canvas { 
            border-radius: 22%; /* 模擬 iOS icon 圓角 */
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 256px; /* 預覽大小 */
            height: 256px;
        }
        .btn-group { display: flex; gap: 15px; }
        button { 
            padding: 12px 24px; 
            font-size: 1rem; 
            font-weight: bold;
            background: linear-gradient(135deg, #3498db, #2980b9); 
            color: white; 
            border: none; 
            border-radius: 50px; 
            cursor: pointer; 
            box-shadow: 0 4px 10px rgba(52, 152, 219, 0.4);
            transition: transform 0.2s;
        }
        button:hover { transform: translateY(-2px); }
        button:active { transform: translateY(0); }
    </style>
</head>
<body>
    <h2>NUO 健身 App - 新版設計圖標</h2>
    
    <div class="preview-area">
        <!-- 實際畫布是 512x512，但 CSS 縮小顯示預覽 -->
        <canvas id="canvasIcon" width="512" height="512"></canvas>
    </div>

    <div class="btn-group">
        <button onclick="downloadIcon(512)">下載 icon-512.png</button>
        <button onclick="downloadIcon(192)">下載 icon-192.png</button>
    </div>

    <script>
        function draw() {
            const canvas = document.getElementById('canvasIcon');
            const ctx = canvas.getContext('2d');
            const w = 512;
            const h = 512;

            // 1. 背景 (高級深藍漸層)
            // 從左上到右下的漸層
            const gradient = ctx.createLinearGradient(0, 0, w, h);
            gradient.addColorStop(0, "#2c3e50"); // 深藍灰
            gradient.addColorStop(1, "#3498db"); // 亮藍
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);

            // --- 開始繪製啞鈴 (儲存狀態以便旋轉) ---
            ctx.save();
            
            // 2. 移動畫布中心並旋轉 45 度
            ctx.translate(w / 2, h / 2);
            ctx.rotate(-45 * Math.PI / 180); // 逆時針轉45度，讓啞鈴看起來往上衝

            // 設定啞鈴參數
            const barWidth = 140;   // 握把長度
            const barThick = 25;    // 握把粗度
            const plateW = 35;      // 每一片槓片的寬度
            const plateH = 200;     // 槓片高度
            const plateCount = 3;   // 一邊幾片 (象徵可調節)
            const gap = 8;          // 槓片間距
            
            // 3. 陰影 (讓啞鈴有懸浮感)
            ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
            ctx.shadowBlur = 20;
            ctx.shadowOffsetY = 10;

            // 4. 繪製握把
            ctx.fillStyle = "#ecf0f1";
            // 畫布已置中，所以 x 座標要扣掉一半寬度
            roundedRect(ctx, -barWidth/2, -barThick/2, barWidth, barThick, 5);

            // 5. 繪製槓片 (左右兩邊)
            // 定義一個畫一邊槓片的函式
            function drawPlates(direction) {
                // direction: 1 為右邊, -1 為左邊
                let startX = (barWidth / 2) * direction;
                
                for(let i = 0; i < plateCount; i++) {
                    // 計算每一片的 X 座標
                    // 如果是右邊，往右疊加；如果是左邊，往左疊加 (需考慮寬度)
                    let x = direction === 1 
                        ? startX + (i * (plateW + gap)) 
                        : startX - ((i + 1) * (plateW + gap)) + gap; // 微調間距
                    
                    // 越外面的槓片稍微小一點點，做出造型感
                    let currentH = plateH - (i * 15);
                    let y = -currentH / 2;

                    // 畫槓片主體
                    ctx.fillStyle = "#ffffff";
                    roundedRect(ctx, x, y, plateW - gap, currentH, 8);
                    
                    // 增加一點點裝飾線條 (質感)
                    ctx.fillStyle = "rgba(0,0,0,0.1)";
                    ctx.fillRect(x + 5, y + 10, (plateW - gap) - 10, currentH - 20);
                }
            }

            drawPlates(1);  // 右邊
            drawPlates(-1); // 左邊

            ctx.restore(); // 恢復畫布旋轉狀態

            // 6. 加上一點點反光 (Glossy effect) - 讓圖標看起來更像玻璃/寶石質感
            ctx.globalCompositeOperation = 'source-over';
            const shine = ctx.createLinearGradient(0, 0, 0, h);
            shine.addColorStop(0, "rgba(255,255,255,0.1)");
            shine.addColorStop(0.5, "rgba(255,255,255,0)");
            ctx.fillStyle = shine;
            ctx.fillRect(0, 0, w, h);
        }

        // 輔助函式：畫圓角矩形
        function roundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        // 初始化繪圖
        draw();

        // 下載功能
        function downloadIcon(size) {
            const sourceCanvas = document.getElementById('canvasIcon');
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tCtx = tempCanvas.getContext('2d');
            
            // 使用高品質縮放
            tCtx.imageSmoothingEnabled = true;
            tCtx.imageSmoothingQuality = "high";
            tCtx.drawImage(sourceCanvas, 0, 0, size, size);

            const link = document.createElement('a');
            link.download = `icon-${size}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }
    </script>
</body>
</html>